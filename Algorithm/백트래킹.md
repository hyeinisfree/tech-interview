# ë°±íŠ¸ë˜í‚¹ BackTracking
> ë°±íŠ¸ë˜í‚¹ì€ í˜„ì¬ ìƒíƒœì—ì„œ ê°€ëŠ¥í•œ ëª¨ë“  í›„ë³´êµ°ì„ ë”°ë¼ ë“¤ì–´ê°€ë©° í•´ê²°ì±…ì— ëŒ€í•œ í›„ë³´ë¥¼ êµ¬ì¶•í•´ ë‚˜ì•„ê°€ë‹¤ ê°€ëŠ¥ì„±ì´ ì—†ë‹¤ê°€ íŒë‹¨ë˜ë©´ ì¦‰ì‹œ í›„ë³´ë¥¼ í¬ê¸°í•˜ë©´ì„œ ì •ë‹µì„ ì°¾ì•„ê°€ëŠ” ë²”ìš©ì ì¸ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

## BackTracking vs DFS
### ë°±íŠ¸ë˜í‚¹(Backtracking)
í•´ë¥¼ ì°¾ì•„ê°€ëŠ” ë„ì¤‘, ì§€ê¸ˆì˜ í•´ê°€ ë  ë§Œí•œì§€ íŒë‹¨í•œ í›„ ìœ ë§í•˜ì§€ ì•Šë‹¤ê³  ê²°ì •ë˜ë©´ ê·¸ ë…¸ë“œì˜ ì´ì „(ë¶€ëª¨)ìœ¼ë¡œ ëŒì•„ê°€(Backtracking) ë‹¤ìŒ ìì‹ ë…¸ë“œë¡œ ì´ë™í•œë‹¤.
í•´ê°€ ë  ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë©´ ìœ ë§í•˜ë‹¤(promising)ê³  í•˜ë©°, ìœ ë§í•˜ì§€ ì•Šì€ ë…¸ë“œì— ê°€ì§€ ì•ŠëŠ” ê²ƒì„ ê°€ì§€ì¹˜ê¸°(pruning)ë¼ê³  í•œë‹¤.

### ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)
DFSëŠ” ê°€ëŠ¥í•œ ëª¨ë“  ê²½ë¡œ(í›„ë³´)ë¥¼ íƒìƒ‰í•œë‹¤. ë”°ë¼ì„œ, ë¶ˆí•„ìš”í•  ê²ƒ ê°™ì€ ê²½ë¡œë¥¼ ì‚¬ì „ì— ì°¨ë‹¨í•˜ê±°ë‚˜ í•˜ëŠ” ë“±ì˜ í–‰ë™ì´ ì—†ìœ¼ë¯€ë¡œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¤„ì¼ ìˆ˜ ì—†ë‹¤.


## ëŒ€í‘œ ë¬¸ì œ : N Queens
```python
class Solution:
    def solveNQueens(self, n):
        self.results = []
        self.col_set = set() # col
        self.diag_set1 = set() # row-col
        self.diag_set2 = set() # row+col
        self.n = n # length
        
        for x in range(n):
            self.bt(0, x, [])
        
        return self.results
    
    def create_str_row(self, col):
        str_list = ['.'] * self.n
        str_list[col] = 'Q'
        return ''.join(str_list)
    
    def bt(self, row, col, board):
        # exit conditions
        if row==self.n or col==self.n:
            return
        if col in self.col_set:
            return
        diag1_info = row-col
        diag2_info = row+col
        if diag1_info in self.diag_set1:
            return
        if diag2_info in self.diag_set2:
            return
        
        # process
        str_line = self.create_str_row(col)
        board.append(str_line)
    
        if len(board) == self.n:
            self.results.append(board.copy())
            board.pop()
            return
        
        # duplicates sets
        self.col_set.add(col)
        self.diag_set1.add(diag1_info)
        self.diag_set2.add(diag2_info)
        
        # recursive calls
        for x in range(self.n):
            self.bt(row+1, x, board)
        
        # duplicates sets pop
        self.diag_set2.remove(diag2_info)
        self.diag_set1.remove(diag1_info)
        self.col_set.remove(col)
        board.pop()
```

## ëŒ€í‘œ ë¬¸ì œ : ìˆœì—´ Permutations
### 1. Recursion
```python 
def permute(arr, r):
    arr.sort()
    used = [False] * len(arr)
    output = []
    
    def generate(chosen, used):
        if len(chosen) == r:
            output.append(chosen[:])
            return

        for i in range(len(arr)):
            if not used[i]:
                chosen.append(arr[i])
                used[i] = True
                generate(chosen, used)
                used[i] = False
                chosen.pop()

    generate([], used)
    return output

```

### 2. Swap
```python
def permute(arr, r):
    arr.sort()
    output = []
    
    def generate(level):
        if level == r:
            output.append(arr[:r])
            return
        for i in range(level, len(arr)):
            arr[i], arr[level] = arr[level], arr[i]
            generate(level+1)
            arr[i], arr[level] = arr[level], arr[i]
            
    generate(0)
    return output
```


## ëŒ€í‘œ ë¬¸ì œ : ì¡°í•© Combinations
```python
def combine(arr, r):
    arr.sort()
    used = [False] * len(arr)
    output = []
    
    def generate(level, chosen, used):
        if len(chosen) == r:
            output.append(chosen[:])
            return
        for i in range(level, len(arr)):
            if not used[i]:
                chosen.append(arr[i])
                used[i] = True
                generate(i+1, chosen, used)
                used[i] = False
                chosen.pop()
        
    generate(0, [], used)
    return output
```


### ğŸ“— ì°¸ê³ 
* [N-Queens - LeetCode](https://leetcode.com/problems/n-queens/)
* [Permutations - LeetCode](https://leetcode.com/problems/permutations/)
* [Combinations - LeetCode](https://leetcode.com/problems/combinations/)